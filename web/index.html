<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title></title>
    <meta name="description" content="">
    <meta name="author" content="Kevin Albertson">

    <style type="text/css">
    </style>

    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
    Open up the console.
    <img />
    <div data-b123="">
    <script src="../base123-example.js"></script>
    <script>
    var encodedFile = str;

        var decoded = [], curByte = 0, bitOfByte = 0;
        let specials = [
            0 // null
            , 10 // newline                
            , 13 // carriage return
            , 34 // double quote
            , 92 // backslash
        ];
    
        // Given an input array of bytes, encode this to base64.
        function encodeToBase64(arr) {
            return btoa(String.fromCodePoint(...arr));
        }

        // This function will push the last 7 bits of the given byte onto the current array,
        // which contains the numeric values of all bytes.
        function push7(byte) {
            byte = byte << 1;
            console.log('Pushing', byte, byte.toString(2));
            // Align this byte to offset for current byte.
            curByte = curByte | (byte >>> bitOfByte);
            bitOfByte += 7;
            if (bitOfByte >= 8) {
                decoded.push(curByte);
                bitOfByte %= 8;
                // Now, take the remainder, left shift by what has been taken.
                curByte = (byte << (7 - bitOfByte)) & 0xFF;
            }
        }

        var unicode = "AÄ¢";

        function decode(base123) {
            decoded = [];
            curByte = 0;
            bitOfByte = 0;
            // TextEncoder() is not very cross-browser. TODO: see if using String.codePointAt is easier to implement.
            // var arr = new TextEncoder().encode(base123String);
            var arr = typeof(base123) == "object" ? new Uint8Array(base123) : new TextDecoder().decode(atob(base123));
            // Now arr is an array of numbers representing raw binary of characters.
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] & 0b10000000) {
                    // 2 byte character.
                    console.log('Two byte code', arr[i].toString(2), arr[i+1].toString(2));
                    
                    var specialIndex = (arr[i] & 0b00011100) >>> 2;
                    console.log('Special index', specialIndex, specialIndex.toString(2));
                    // Since we're using Uint8Arrays, left shifting should cut off.
                    var b1 = (arr[i] & 0b00000001) << 6;
                    var b2 = arr[i+1] & 0b00111111;
                    console.log('Special inflated to ', specials[specialIndex].toString(2));

                    push7(specials[specialIndex]);

                    var remainder = b1 | b2;
                    console.log('Remainder', remainder, remainder.toString(2));
                    // Check if ending bit is set, if so, ignore remainder.
                    if (arr[i] & 0b00000010) {
                        console.log('Ending bit set, not adding remainder');
                    } else {
                        push7(remainder);
                    }
                    i++;
                } else {
                    // Regular ascii.
                    console.log('Adding', arr[i], arr[i].toString(2));
                    push7(arr[i])
                }
            }
            return decoded;
        }
        
        function encodeToBase123(base64) {
            // Can pass base64 string or number array.
            var data = typeof(base64) == "object" ? base64 : atob(base64);
            var curIndex = 0, curMask = 0b10000000, stringData = [];
            var bitsFound = 0;

            // Returns false when no more bits are left.            
            function getOne() {
                if (curIndex >= data.length) return false;
                bit = (data[curIndex] & curMask) > 0 ? 1 : 0;
                bitsFound++;

                curMask = curMask >>> 1;
                if (curMask == 0) {
                    curIndex++;
                    curMask = 0b10000000
                }
                return bit;
            }
            
            function get7() {
                if (curIndex >= data.length) return false;
                var b = 0;
                for (var i = 0; i < 7; i++) {
                    b = b << 1;
                    var bit = getOne();
                    if (bit === false) continue; // Still want to return whatever we have, left shifted.
                    b |= bit;
                }
                return b;
            }
            
            while(true) {
                // Grab 7 bits.
                var bits = get7();
                if (bits === false) break;
                //console.log('Got 7 bits', bits.toString(2));

                var specialIndex = specials.indexOf(bits);
                if (specialIndex != -1) {
                    console.log('Special time for bits ', bits.toString(2), bits);
                    var b1 = 0b11000000, b2 = 0b10000000;
                    b1 |= (0b111 & specialIndex) << 2;
                    // See if there are any bits after this special sequence.
                    // If there are, then there can be a variable range of 7 bits in last bit of
                    // special byte and remaining 6 in other.
                    // Otherwise, there are a variable number of 7 in the special code. Either way,
                    // % 8 should chop off the excess.
                    var nextBits = get7();
                    if (nextBits === false) {
                        console.log(' Special code contains the last 7ish bits.');
                        b1 |= 0b11000010; // Turn on flag.
                    } else {
                        console.log(' There are additional bits', nextBits.toString(2))
                        // Push first bit onto first byte, remaining 6 onto second.
                        var firstBit = (nextBits & 0b01000000) > 0 ? 1 : 0;
                        console.log(firstBit, nextBits.toString(2), nextBits & 0b01000000, b1.toString(2));
                        b1 |= firstBit;
                        console.log(b1.toString(2));
                        b2 |= nextBits & 0b00111111;
                    }
                    stringData.push(b1);
                    stringData.push(b2);
                    console.log(' Unicode character is ', b1.toString(2), b2.toString(2));
                } else {
                    stringData.push(bits);
                }
            }
            return stringData;
        }

        function assertEqual(arr1, arr2) {
            let panic = () => { 
                let reduction = (str, val) => { return str + ',' + val.toString(2); };
                throw arr1.reduce(reduction, "") + " != " + arr2.reduce(reduction, "");
            };
            if (arr1.length != arr2.length) panic();
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] != arr2[i]) panic();
            }
        }

        function testEncoding() {
            // Encode in base123, then decode, check that equal to the original.
            // Let's first encode one byte of just ones.
            var data = [0b11111111];
            assertEqual(encodeToBase123(data), [0b01111111, 0b01000000]);

            // Let's try encoding alternating bits.
            data = [0b10101010, 0b10101010, 0b10101010, 0b10101010];
            assertEqual(encodeToBase123(data), [0b01010101, 0b00101010, 0b01010101, 0b00101010, 0b01010000]);

            // Let's test sequences which produce special bits.
            data = [0b00000001, 0b11111111];
            assertEqual(encodeToBase123(data), [0b11000001, 0b10111111, 0b01100000]);

            // Let's test a sequence where there are no remaining bits after special. TODO: annoying.
        }

        function testDecoding() {
            // var data = [0b11111111];
            // var encoded = encodeToBase123(data);
            // assertEqual(encoded, [0b01111111, 0b01000000]);
            // let decoded = decode(encoded);
            // assertEqual(data, decoded);

            // data = [0b10101010, 0b10101010, 0b10101010, 0b10101010];
            // encoded = encodeToBase123(data);
            // assertEqual(encoded, [0b01010101, 0b00101010, 0b01010101, 0b00101010, 0b01010000]);
            // decoded = decode(encoded);
            // assertEqual(data, decoded);

            // data = [0b00000001, 0b11111111];
            // encoded = encodeToBase123(data);
            // assertEqual(encoded, [0b11000001, 0b10111111, 0b01100000]);
            // decoded = decode(encoded);
            // assertEqual(decoded, data);

            data = [0b11000010,0b10001001];
            encoded = encodeToBase123(data);
            assertEqual(encoded, [0b01100001, 0b11001100, 0b10100000])
            decoded = decode(encoded);
            assertEqual(data, decoded);

            // TODO: Test a full end-to-end test, starting with a base64 string, ending with the
            // same base64 string.
        }

        function getCodePoints(dataString) {
            var arr = [];
            for (var i = 0; i < dataString.length; i++) {
                arr.push(dataString.codePointAt(i));
            }
            return arr;
        }
        function fullTest() {
            var dataStringForm = atob(base64);
            var dataByteArray = getCodePoints(dataStringForm);// new TextEncoder().encode(dataStringForm);
            //printValues(dataByteArray);
            encodedByteArray = encodeToBase123(dataByteArray);

            //printValues(encodedByteArray);
            decodedByteArray = decode(encodedByteArray);
            //printValues(decodedByteArray);
            //assertEqual(encodedByteArray, []);
            assertEqual(dataByteArray, decodedByteArray);
            var decodedByteIntArray = new Uint8Array(decodedByteArray);
            //window.decodedStringForm = btoa(new TextDecoder().decode(decodedByteIntArray));
            var blob = new Blob([decodedByteIntArray], {type: "image/jpeg"});
            blob.type = "image/jpeg";
            console.log(blob);
            window.blob = blob;
            var url = URL.createObjectURL(blob);
            document.querySelector('img').src = url;

            console.log("Base64 takes " + base64.length + " bytes");
            console.log("Base123 takes " + encodedByteArray.length + " bytes");
            console.log("Raw data takes " + dataByteArray.length + " bytes");
        }

        function testFile() {
            var dataStringForm = atob(base64);
            var dataByteArray = getCodePoints(dataStringForm);
            encodedByteArray = new Uint8Array(encodeToBase123(dataByteArray));

            var str = (new TextDecoder()).decode(encodedByteArray);
            var byteArrayAgain = (new TextEncoder()).encode(str);
            assertEqual(encodedByteArray, byteArrayAgain); // HOW!

            if (str != encodedFile) throw("Inequality!")
            var encodedFileData = (new TextEncoder()).encode(fileData);

            console.log("Base123 encoded string takes " + dataByteArray.length + " bytes");
            console.log("Base123 encoded file takes " + encodedFileData.length + " bytes");
        }

        function testFromString() {
            // Problem: we have a base123 string, and want the byte data (for now to confirm).
            // Solution: convert str to Uint8Array using codepoints. Why TextDecoder doesn't work
            // is beyond me, but since TextEncoder() followed by TextDecoder() doesn't give the
            // original string back is also suspicious.
            var dataStringForm = atob(base64);
            var dataByteArray = getCodePoints(dataStringForm);
            var encodedByteArray = new Uint8Array(encodeToBase123(dataByteArray));

            // Now, we want to make "str" into an equal byte array.
            var strByteArray = [];
            for (var i = 0; i < str.length; i++) {
                var codePoint = str.charCodeAt(i);
                if (codePoint.toString(2).length > 7) {
                    if (codePoint > 0xFF) {
                        console.log("Detected two-byte codepoint", codePoint.toString(2));
                        var corrected = codePoint - 0xFF;
                        console.log("Corrected? ", corrected, corrected.toString(2));
                    }
                    //console.log(codePoint.toString(2));
                }
            }
        }

        function printValues(arr) {
            var sArr = [];
            arr.forEach((val) => {
                var bitString = val.toString(2);
                var s = "00000000".substring(0, 8 - bitString.length) + bitString;
                sArr.push(s);
            });
            console.log(sArr.join('-'));
        }
        
        var base64 = "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";
        

    </script>
</body>
</html>